DAA Notes 2018-01-25

Breadth First Search
    BFS Finds S-T connectivity of a graph.
        - Given a node S and a node T, it tries to give you a path from S to T.
    - We explore outward S in all possible directions, adding nodes one layer at a time.
    - We start with S, include all nodes that are joined by an edge S.
    - Include all the nodes that are joined by an edge to any node in the previous layer.

    BFS is not only determining the nodes that S can reach, it also computes the shortest path to them.

    Claim: Let T be the BFS tree
        - Let {x}{y} be the nodes in T belonging to layer Li and Lj
        - Let (x,y) be an edge in graph G, then i and j differ by AT MOST 1.
    Proof (contradiction):
        Suppose that i and j differ by more than 1 so i < (j-1).
        Consider a point in BFS also where edges incident to u are being examined.
        Since x belongs to layer Li, the only nodes discovered from x belong to layer L(i+1) and earlier.
        Hence if y is a neighbor of x, then it should have been discovered by this point at the latest and should belong to layer L(i+1) or ealier.
        PROOF END
    Let set R be a connected component of G containing S
        Connected Component is a graph in a set of graphs which is not connected to any vertex in the other graphs in the set.
        R={s}
        If we find an edge (u,v) where u is an element of R and v is not an element of R, then we can add v to R safely.
        In other words, if A is a member of B, and B is a member of C, then A is a member of C.

Methods of programming graph representations:
    For an adjacency matrix, we need to build a matrix which takes up a large amount of space.
    Otherwise, we can use a list of lists to represent a graph while using less space.

    To traverse an adjacency matrix:
        for(i = 0; i < dimension; i++)
            for(j = 0; j < dimension; j++)
                Matrix[i][j]
        
        If we swap M[i][j] with M[j][i], mathematically these two are the exact same complexity. However because of the way that a 2D array is stored in memory, M[i][j] will be much faster than M[j][i]. So whenever possible, traverse along each column in a row before going to the next row instead of going row by row then going to the next column.
    
        When storing a 2D array, because of Row Major Order, rows are stored into memory one at a time. But if you are doing M[j][i], the computer still loads that first row into memory, reads the first element, then loads the next row into memory, reads the element, and so on.

        So reading row by row instead of column by column, there is a lot more memory swapping.