\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry} 
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage{tabto}
\usepackage[yyyymmdd]{datetime}
\renewcommand{\dateseparator}{--}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}

% For definitions
%\newtheorem{defn}{Definition}[section]
%\newtheorem{thrm}{Theorem}[section]
%\newtheorem{ex}[Example}[section]
\newtheorem*{ex}{Example}
\newtheorem*{defn}{Definition}
\newtheorem*{thrm}{Theorem}
\newtheorem*{lemma}{Lemma}
\newtheorem*{result}{Result}


% For circled text
\usepackage{tikz}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=0.8pt] (char) {#1};}}

% For equation system alignment
\usepackage{systeme,mathtools}
% Usage:
%	\[
%	\sysdelim.\}\systeme{
%	3z +y = 10,
%	x + y +  z = 6,
%	3y - z = 13}

\newenvironment{problem}[2][Problem]{\begin{trivlist}
\item[\hskip \labelsep {\bfseries #1}\hskip \labelsep {\bfseries #2.}]}{\end{trivlist}}
%If you want to title your bold things something different just make another thing exactly like this but replace "problem" with the name of the thing you want, like theorem or lemma or whatever
 
%used for matrix vertical line
\makeatletter
\renewcommand*\env@matrix[1][*\c@MaxMatrixCols c]{%
  \hskip -\arraycolsep
  \let\@ifnextchar\new@ifnextchar
  \array{#1}}
\makeatother 
 
 




\begin{document}
\TabPositions{4cm}
%\renewcommand{\qedsymbol}{\filledbox}
%Good resources for looking up how to do stuff:
%Binary operators: http://www.access2science.com/latex/Binary.html
%General help: http://en.wikibooks.org/wiki/LaTeX/Mathematics
%Or just google stuff
 
\today {} Design and Analysis of Algorithms Notes\\

\section{Depth First Search (DFS)}
\begin{defn}
For graph $G$:\\
You start with $S$ and try first edge leading to $V$. Then you follow the first edge leading out of $V$. Continue like this until you reach a dead end. Then backtrack until you get to node with an unvisited node.
\end{defn}
\subsection{BFS vs DFS}
Similarities:
	\begin{itemize}
	\item Cross through all the nodes.
	\item Similar level of efficiency.
	\end{itemize}
Differences:
	\begin{itemize}
	\item Ordering of nodes are very different.
	\end{itemize}

\subsection{DFS (u)}
	\begin{verbatim}
	Mark u as explored and add u to R
	Foreach edge (u,v) incident to v
	  IF v is not marked as explored then
	    recursively invoke DFS(v)
	  Endif
	Endfor
	\end{verbatim}

\subsection{Adjacency Matrix/ Adjacency List}
Matrices are nice for understanding graphs but they aren't nice for implementing them since they use space $O(n^2)$.\\
\begin{ex}
Given we have $n$ vertices and $m$ edges:\\
Adjacency matrix has space complexity of $O(n+m)$ when given a sparse graph meaning the number of edges is not much larger than the number of nodes. Since there are $n+m$ representations of the graph, then going through the structure (identifying all edges) will also take $O(n+m)$ time.
\end{ex}
\begin{ex}
Given a matrix with N=100 items and a cost of $c$. Then the max cost is $100c$.\\
Then the number of elements in the list will be 100 and the time to traverse the list will be $100c$ in other words $(n+m)c$ where $(n+m)$ is the entire representation of the graph.
\end{ex}

Adjacency List needs $O(n+m)$ space for sparse graphs.
\begin{enumerate}
\item Array Adj where Adj[v] is a record containing the list of all nodes adjacent to $v$.
\item For undirected graph $G(V,E)$ each edge $e(v,w)$ occurs on two adjacency lists: node w appears on the list for node $v$, node $v$ appears on the list for node $w$.
\item Need an array of pointers of length n to setup list in Adj; we need the space for all the lists.
\item Length of the list may vary but in (1) and (2) $e(v,w)$ appears in exactly two of the lists: One for $v$ and one for $w$. Thus the total length of all the lists is $2m$. \qed
\end{enumerate}
Best case space complexity for list is $\Omega(n)$, worst case is $O(n^2)$ for when graph is complete, and average case is $\Theta(m+n)$.\\
BFS Traversal is $O(n+m) = O(n^2)$.






\end{document}